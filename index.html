<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Audio Scope Analyzer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #1a1a1a;
      color: #00ff00;
      min-height: 100vh;
      padding: 5px;
      overflow-x: hidden;
    }

    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 5px 0;
      padding: 8px;
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 4px;
      flex-wrap: wrap;
    }

    .scope-title {
      font-size: 0.9rem;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
      letter-spacing: 1px;
      font-weight: bold;
      white-space: nowrap;
    }

    .main-toggle {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      border: 2px solid #00ff00;
      background: #000;
      color: #00ff00;
      border-radius: 4px;
      cursor: pointer;
      text-transform: uppercase;
      touch-action: manipulation;
      transition: all 0.2s;
      box-shadow: 0 0 8px rgba(0,255,0,0.3);
    }

    .main-toggle:active {
      transform: scale(0.95);
    }

    .main-toggle.active {
      background: #00ff00;
      color: #000;
      border-color: #00ff00;
      box-shadow: 0 0 15px rgba(0,255,0,0.6);
    }

    button {
      padding: 12px 24px;
      font-size: 14px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      border: 2px solid #00ff00;
      background: #000;
      color: #00ff00;
      border-radius: 4px;
      cursor: pointer;
      text-transform: uppercase;
      touch-action: manipulation;
    }

    button:active {
      background: #00ff00;
      color: #000;
    }

    .scope-panel {
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 4px;
      padding: 6px;
      margin: 5px 0;
    }

    .scope-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      flex-wrap: wrap;
    }

    h2 {
      font-size: 0.85rem;
      color: #00ff00;
      text-shadow: 0 0 5px #00ff00;
      margin: 3px 0;
    }

    .knobs {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .knob-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
    }

    .knob {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #555, #222);
      border: 2px solid #000;
      position: relative;
      cursor: pointer;
      touch-action: none;
    }

    .knob::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 50%;
      transform: translateX(-50%);
      width: 2px;
      height: 12px;
      background: #00ff00;
      border-radius: 2px;
      box-shadow: 0 0 5px #00ff00;
    }

    .knob-label {
      font-size: 8px;
      color: #888;
      text-transform: uppercase;
    }

    .knob-value {
      font-size: 9px;
      color: #00ff00;
      font-weight: bold;
    }

    .toggle-btn {
      padding: 4px 8px;
      font-size: 10px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      border: 2px solid #00ff00;
      background: #000;
      color: #00ff00;
      border-radius: 3px;
      cursor: pointer;
      text-transform: uppercase;
      touch-action: manipulation;
      transition: all 0.2s;
    }

    .toggle-btn.active {
      background: #00ff00;
      color: #000;
      box-shadow: 0 0 10px rgba(0,255,0,0.5);
    }

    canvas {
      width: 100%;
      height: 140px;
      display: block;
      background: #000;
      border: 2px solid #111;
      border-radius: 4px;
      touch-action: none;
    }

    #heatmap {
      height: 200px;
    }

    .qr-code-container {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #2a2a2a;
      border: 2px solid #00ff00;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 0 20px rgba(0,255,0,0.4);
      z-index: 1000;
      display: none;
    }

    .qr-code-container h3 {
      font-size: 0.75rem;
      color: #00ff00;
      text-align: center;
      margin-bottom: 8px;
      text-shadow: 0 0 5px #00ff00;
    }

    .qr-code-container img {
      display: block;
      background: white;
      padding: 5px;
      border-radius: 4px;
    }

    /* Show QR code only on desktop (wider screens) */
    @media (min-width: 768px) {
      .qr-code-container {
        display: block;
      }
    }

    .pitch-display {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 6px;
      padding: 6px;
      background: #000;
      border: 2px solid #00ff00;
      border-radius: 4px;
      text-align: center;
    }

    .pitch-info {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .pitch-note {
      font-size: 1.3rem;
      color: #00ff00;
      text-shadow: 0 0 8px #00ff00;
      font-weight: bold;
      margin: 0;
    }

    .pitch-freq {
      font-size: 0.85rem;
      color: #0f0;
      margin: 0;
    }

    .pitch-cents {
      font-size: 0.75rem;
      color: #ffff00;
      margin: 0;
    }

    .pitch-cents.flat {
      color: #ff8800;
    }

    .pitch-cents.sharp {
      color: #00ffff;
    }

    /* Portrait mode: larger elements to fill space */
    @media (orientation: portrait) {
      canvas {
        height: 180px;
      }

      .scope-panel {
        padding: 10px;
        margin: 8px 0;
      }

      .knob {
        width: 60px;
        height: 60px;
        border: 3px solid #000;
      }

      .knob::after {
        top: 6px;
        width: 3px;
        height: 18px;
      }

      .knob-label {
        font-size: 10px;
      }

      .knob-value {
        font-size: 11px;
      }

      .controls {
        padding: 12px;
        margin: 8px 0;
      }

      .scope-title {
        font-size: 1.1rem;
      }

      .main-toggle {
        padding: 14px 28px;
        font-size: 16px;
      }

      h2 {
        font-size: 1rem;
      }

      .pitch-note {
        font-size: 1.8rem;
      }

      .pitch-freq {
        font-size: 1rem;
      }

      .pitch-cents {
        font-size: 0.9rem;
      }

      .pitch-info {
        gap: 15px;
      }

      .scope-header {
        margin-bottom: 10px;
      }

      .toggle-btn {
        padding: 6px 12px;
        font-size: 11px;
      }
    }

    /* Landscape mode: side-by-side layout */
    @media (orientation: landscape) and (min-width: 600px) {
      .controls {
        flex-wrap: nowrap;
      }

      .scope-container {
        display: flex;
        gap: 10px;
        align-items: flex-start;
      }

      .scope-panel {
        flex: 1;
        margin: 0 !important;
      }

      .pitch-info {
        flex: 1;
        justify-content: space-around;
        max-width: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="controls">
    <div class="scope-title">◈ AUDIO SCOPE ◈</div>
    <button class="main-toggle" id="toggleBtn">START</button>
    <div class="pitch-info">
      <div class="pitch-note" id="pitchNote">--</div>
      <div class="pitch-freq" id="pitchFreq">--- Hz</div>
      <div class="pitch-cents" id="pitchCents">--- cents</div>
    </div>
  </div>

  <div class="scope-container">
  <div class="scope-panel">
    <div class="scope-header">
      <h2>◆ OSCILLOSCOPE</h2>
      <div class="knobs">
        <button class="toggle-btn active" id="autoFitBtn">Auto Fit</button>
        <div class="knob-group">
          <div class="knob" id="smoothingKnob" data-value="80"></div>
          <div class="knob-label">Smooth</div>
          <div class="knob-value" id="smoothingValue">0.80</div>
        </div>
      </div>
    </div>
    <canvas id="oscilloscope"></canvas>
  </div>

  <div class="scope-panel">
    <div class="scope-header">
      <h2>◆ SPECTRUM (FFT)</h2>
      <div class="knobs">
        <div class="knob-group">
          <div class="knob" id="fftSizeKnob" data-value="2048"></div>
          <div class="knob-label">FFT Size</div>
          <div class="knob-value" id="fftSizeValue">2048</div>
        </div>
        <div class="knob-group">
          <div class="knob" id="gainKnob" data-value="100"></div>
          <div class="knob-label">Gain</div>
          <div class="knob-value" id="gainValue">1.0x</div>
        </div>
      </div>
    </div>
    <canvas id="spectrum"></canvas>
  </div>
  </div>

  <div class="scope-panel">
    <div class="scope-header">
      <h2>◆ FREQUENCY HEATMAP (LOGARITHMIC TIME)</h2>
    </div>
    <canvas id="heatmap"></canvas>
  </div>

  <div class="qr-code-container" id="qrContainer">
    <h3>SCAN TO OPEN ON MOBILE</h3>
    <img id="qrCode" alt="QR Code">
  </div>

  <script>
    // Audio components
    let audioContext, analyser, microphone, dataArray, bufferLength, animationId;
    let currentGain = 1.0;
    const fftSizes = [512, 1024, 2048, 4096, 8192];
    let currentFFTIndex = 2;
    let autoFitEnabled = true;
    let detectedFrequency = 0;

    // Canvas setup
    const oscCanvas = document.getElementById('oscilloscope');
    const oscCtx = oscCanvas.getContext('2d');
    const specCanvas = document.getElementById('spectrum');
    const specCtx = specCanvas.getContext('2d');
    const heatmapCanvas = document.getElementById('heatmap');
    const heatmapCtx = heatmapCanvas.getContext('2d');

    // Heatmap data storage
    const heatmapHistory = [];
    const MAX_HISTORY_TIME = 600000; // 10 minutes in milliseconds

    // Set canvas resolution
    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
    }

    setupCanvas(oscCanvas);
    setupCanvas(specCanvas);
    setupCanvas(heatmapCanvas);

    // Generate QR code for current URL
    function generateQRCode() {
      const currentUrl = window.location.href;
      const qrCodeImg = document.getElementById('qrCode');
      // Use QR Server API to generate QR code
      qrCodeImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(currentUrl)}`;
    }

    // Generate QR code on page load
    generateQRCode();

    // UI elements
    const toggleBtn = document.getElementById('toggleBtn');
    const autoFitBtn = document.getElementById('autoFitBtn');
    const pitchNoteEl = document.getElementById('pitchNote');
    const pitchFreqEl = document.getElementById('pitchFreq');
    const pitchCentsEl = document.getElementById('pitchCents');
    let isRunning = false;

    // Auto-fit toggle
    autoFitBtn.addEventListener('click', () => {
      autoFitEnabled = !autoFitEnabled;
      autoFitBtn.classList.toggle('active', autoFitEnabled);
    });

    // Note names
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // Convert frequency to note name and cents offset
    function frequencyToNote(frequency) {
      const A4 = 440;
      const C0 = A4 * Math.pow(2, -4.75);
      const halfSteps = Math.round(12 * Math.log2(frequency / C0));
      const noteIndex = halfSteps % 12;
      const octave = Math.floor(halfSteps / 12);
      const noteName = noteNames[noteIndex];
      
      // Calculate cents offset from perfect pitch
      const perfectFreq = C0 * Math.pow(2, halfSteps / 12);
      const cents = Math.round(1200 * Math.log2(frequency / perfectFreq));
      
      return {
        note: noteName + octave,
        frequency: frequency,
        cents: cents
      };
    }

    // Knob handling
    let activeKnob = null;
    let startY = 0;
    let startValue = 0;

    function handleStart(knob, clientY, e) {
      activeKnob = knob;
      startY = clientY;
      startValue = parseInt(knob.dataset.value);
      e.preventDefault();
    }

    function handleMove(clientY) {
      if (!activeKnob) return;
      
      const delta = startY - clientY;
      const knobId = activeKnob.id;
      
      if (knobId === 'fftSizeKnob') {
        currentFFTIndex = Math.max(0, Math.min(4, Math.floor(startValue / 100 + delta / 50)));
        const newValue = fftSizes[currentFFTIndex];
        activeKnob.dataset.value = currentFFTIndex * 100;
        document.getElementById('fftSizeValue').textContent = newValue;
        updateRotation(activeKnob, currentFFTIndex / 4);
        if (analyser) {
          analyser.fftSize = newValue;
          bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);
        }
      } else if (knobId === 'smoothingKnob') {
        const newValue = Math.max(0, Math.min(99, startValue + delta));
        activeKnob.dataset.value = newValue;
        const smoothing = newValue / 100;
        document.getElementById('smoothingValue').textContent = smoothing.toFixed(2);
        updateRotation(activeKnob, smoothing);
        if (analyser) analyser.smoothingTimeConstant = smoothing;
      } else if (knobId === 'gainKnob') {
        const newValue = Math.max(10, Math.min(300, startValue + delta * 2));
        activeKnob.dataset.value = newValue;
        currentGain = newValue / 100;
        document.getElementById('gainValue').textContent = currentGain.toFixed(1) + 'x';
        updateRotation(activeKnob, (newValue - 10) / 290);
      }
    }

    function updateRotation(knob, value) {
      const rotation = value * 270 - 135;
      knob.style.transform = `rotate(${rotation}deg)`;
    }

    // Initialize knobs
    document.querySelectorAll('.knob').forEach(knob => {
      knob.addEventListener('mousedown', e => handleStart(knob, e.clientY, e));
      knob.addEventListener('touchstart', e => handleStart(knob, e.touches[0].clientY, e), { passive: false });
    });

    document.addEventListener('mousemove', e => handleMove(e.clientY));
    document.addEventListener('touchmove', e => { if (activeKnob) handleMove(e.touches[0].clientY); }, { passive: false });
    document.addEventListener('mouseup', () => activeKnob = null);
    document.addEventListener('touchend', () => activeKnob = null);

// Toggle audio
    toggleBtn.addEventListener('click', async () => {
      if (!isRunning) {
        // Start audio
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioContext = new (window.AudioContext || window.webkitAudioContext)();

          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }

          analyser = audioContext.createAnalyser();
          analyser.fftSize = fftSizes[currentFFTIndex];
          analyser.smoothingTimeConstant = 0.8;

          bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);

          microphone = audioContext.createMediaStreamSource(stream);
          microphone.connect(analyser);

          window.currentStream = stream;

          isRunning = true;
          toggleBtn.textContent = 'STOP';
          toggleBtn.classList.add('active');

          visualize();
        } catch (error) {
          alert('Microphone error: ' + error.message);
        }
      } else {
        // Stop audio
        if (animationId) cancelAnimationFrame(animationId);
        if (microphone) microphone.disconnect();
        if (window.currentStream) {
          window.currentStream.getTracks().forEach(track => track.stop());
          window.currentStream = null;
        }
        if (audioContext) audioContext.close();

        isRunning = false;
        toggleBtn.textContent = 'START';
        toggleBtn.classList.remove('active');

        pitchNoteEl.textContent = '--';
        pitchFreqEl.textContent = '--- Hz';
        pitchCentsEl.textContent = '--- cents';
        pitchCentsEl.className = 'pitch-cents';

        oscCtx.clearRect(0, 0, oscCanvas.width, oscCanvas.height);
        specCtx.clearRect(0, 0, specCanvas.width, specCanvas.height);
      }
    });

    // Visualization
    function visualize() {
      animationId = requestAnimationFrame(visualize);
      drawOscilloscope();
      drawSpectrum();
      drawHeatmap();
    }

    function drawOscilloscope() {
      analyser.getByteTimeDomainData(dataArray);
      
      const width = oscCanvas.width / (window.devicePixelRatio || 1);
      const height = oscCanvas.height / (window.devicePixelRatio || 1);
      
      oscCtx.fillStyle = '#000';
      oscCtx.fillRect(0, 0, width, height);
      
      // Grid
      oscCtx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
      oscCtx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const y = (i / 10) * height;
        oscCtx.beginPath();
        oscCtx.moveTo(0, y);
        oscCtx.lineTo(width, y);
        oscCtx.stroke();
      }
      
      // Calculate how many samples to display
      let samplesToDisplay = bufferLength;
      if (autoFitEnabled && detectedFrequency > 20) {
        // Show 4 cycles of the detected frequency
        const cyclesPerSecond = detectedFrequency;
        const secondsFor4Cycles = 4 / cyclesPerSecond;
        const sampleRate = audioContext.sampleRate;
        samplesToDisplay = Math.min(bufferLength, Math.floor(secondsFor4Cycles * sampleRate));
      }

      // Waveform
      oscCtx.lineWidth = 2;
      oscCtx.strokeStyle = '#0f0';
      oscCtx.shadowBlur = 10;
      oscCtx.shadowColor = '#0f0';
      oscCtx.beginPath();

      const sliceWidth = width / samplesToDisplay;
      let x = 0;

      for (let i = 0; i < samplesToDisplay; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * height / 2;

        if (i === 0) oscCtx.moveTo(x, y);
        else oscCtx.lineTo(x, y);

        x += sliceWidth;
      }

      oscCtx.lineTo(width, height / 2);
      oscCtx.stroke();
      oscCtx.shadowBlur = 0;
    }

    function drawSpectrum() {
      analyser.getByteFrequencyData(dataArray);
      
      const width = specCanvas.width / (window.devicePixelRatio || 1);
      const height = specCanvas.height / (window.devicePixelRatio || 1);
      
      specCtx.fillStyle = '#000';
      specCtx.fillRect(0, 0, width, height);

      // Grid
      specCtx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
      specCtx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const y = (i / 10) * height;
        specCtx.beginPath();
        specCtx.moveTo(0, y);
        specCtx.lineTo(width, y);
        specCtx.stroke();
      }

      // Find peak frequency
      let maxVal = 0;
      let maxIndex = 0;
      const minFreq = 20; // Ignore frequencies below 20Hz
      const nyquist = audioContext.sampleRate / 2;
      const minIndex = Math.floor(minFreq / (nyquist / bufferLength));
      
      for (let i = minIndex; i < bufferLength; i++) {
        if (dataArray[i] > maxVal) {
          maxVal = dataArray[i];
          maxIndex = i;
        }
      }

      // Update pitch display and store frequency for oscilloscope auto-fit
      if (maxVal > 100) { // Threshold for significant signal
        const frequency = (maxIndex * nyquist) / bufferLength;
        detectedFrequency = frequency; // Store for oscilloscope auto-fit
        const pitchInfo = frequencyToNote(frequency);
        
        pitchNoteEl.textContent = pitchInfo.note;
        pitchFreqEl.textContent = pitchInfo.frequency.toFixed(1) + ' Hz';
        
        if (pitchInfo.cents === 0) {
          pitchCentsEl.textContent = 'Perfect';
          pitchCentsEl.className = 'pitch-cents';
        } else if (pitchInfo.cents > 0) {
          pitchCentsEl.textContent = '+' + pitchInfo.cents + ' cents (sharp)';
          pitchCentsEl.className = 'pitch-cents sharp';
        } else {
          pitchCentsEl.textContent = pitchInfo.cents + ' cents (flat)';
          pitchCentsEl.className = 'pitch-cents flat';
        }
      } else {
        detectedFrequency = 0; // No significant frequency
        pitchNoteEl.textContent = '--';
        pitchFreqEl.textContent = '--- Hz';
        pitchCentsEl.textContent = '--- cents';
        pitchCentsEl.className = 'pitch-cents';
      }

      const barWidth = (width / bufferLength) * 2.5;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const barHeight = (dataArray[i] / 255) * height * currentGain;
        const intensity = dataArray[i] / 255;

        specCtx.fillStyle = `rgb(0, ${Math.floor(255 * intensity)}, 0)`;
        specCtx.shadowBlur = 5;
        specCtx.shadowColor = '#0f0';

        specCtx.fillRect(x, height - barHeight, barWidth, barHeight);
        x += barWidth + 1;
      }
      specCtx.shadowBlur = 0;
    }

    function drawHeatmap() {
      const now = Date.now();
      
      // Get current frequency data
      analyser.getByteFrequencyData(dataArray);
      
      // Store frequency snapshot with timestamp
      heatmapHistory.push({
        timestamp: now,
        data: new Uint8Array(dataArray)
      });
      
      // Remove old data beyond MAX_HISTORY_TIME
      while (heatmapHistory.length > 0 && now - heatmapHistory[0].timestamp > MAX_HISTORY_TIME) {
        heatmapHistory.shift();
      }
      
      const width = heatmapCanvas.width / (window.devicePixelRatio || 1);
      const height = heatmapCanvas.height / (window.devicePixelRatio || 1);
      
      heatmapCtx.fillStyle = '#000';
      heatmapCtx.fillRect(0, 0, width, height);
      
      if (heatmapHistory.length === 0) return;
      
      const nyquist = audioContext.sampleRate / 2;
      const signalThreshold = 30; // Intensity threshold to consider as active signal
      
      // Find the maximum frequency with significant signal across recent history
      let maxActiveFreqBin = 0;
      const recentHistoryCount = Math.min(30, heatmapHistory.length); // Check last 30 frames (~0.5 sec)
      
      for (let i = heatmapHistory.length - recentHistoryCount; i < heatmapHistory.length; i++) {
        const snapshot = heatmapHistory[i];
        for (let j = 0; j < bufferLength; j++) {
          if (snapshot.data[j] > signalThreshold && j > maxActiveFreqBin) {
            maxActiveFreqBin = j;
          }
        }
      }
      
      // Calculate max frequency and add 20% headroom
      let maxDisplayFreq;
      if (maxActiveFreqBin === 0) {
        maxDisplayFreq = nyquist; // No signal, show full range
      } else {
        const detectedMaxFreq = (maxActiveFreqBin * nyquist) / bufferLength;
        maxDisplayFreq = Math.min(nyquist, detectedMaxFreq * 1.2); // Add 20% headroom
        // Ensure minimum display range of 200Hz
        maxDisplayFreq = Math.max(200, maxDisplayFreq);
      }
      
      const maxDisplayBin = (maxDisplayFreq / nyquist) * bufferLength;
      
      // Logarithmic time scale where last minute = half the display
      const c = 1;
      const k = width / (2 * Math.log(61));
      
      function ageToX(ageSeconds) {
        return width - k * Math.log(ageSeconds + c);
      }
      
      const oldestAge = (now - heatmapHistory[0].timestamp) / 1000;
      
      // Draw each time slice
      for (let i = 0; i < heatmapHistory.length; i++) {
        const snapshot = heatmapHistory[i];
        const ageSeconds = (now - snapshot.timestamp) / 1000;
        const x = ageToX(ageSeconds);
        
        // Calculate width for this slice (distance to next slice or edge)
        let sliceWidth;
        if (i < heatmapHistory.length - 1) {
          const nextAge = (now - heatmapHistory[i + 1].timestamp) / 1000;
          const nextX = ageToX(nextAge);
          sliceWidth = Math.abs(nextX - x);
        } else {
          sliceWidth = width - x;
        }
        
        sliceWidth = Math.max(1, sliceWidth); // At least 1 pixel
        
        // Draw frequency bins vertically (only up to maxDisplayBin)
        for (let j = 0; j < maxDisplayBin; j++) {
          const intensity = snapshot.data[j] / 255;
          const frequency = (j * nyquist) / bufferLength;
          
          // Skip very low frequencies for clarity
          if (frequency < 20) continue;
          
          // Y position: lower frequencies at bottom, higher at top
          // Scale based on maxDisplayBin instead of bufferLength
          const y = height - (j / maxDisplayBin) * height;
          const freqBinHeight = height / maxDisplayBin;
          
          // Color based on intensity: black -> green -> yellow -> red
          let r, g, b;
          if (intensity < 0.5) {
            // Black to green
            r = 0;
            g = Math.floor(intensity * 2 * 255);
            b = 0;
          } else {
            // Green to yellow to red
            r = Math.floor((intensity - 0.5) * 2 * 255);
            g = 255;
            b = 0;
          }
          
          heatmapCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
          heatmapCtx.fillRect(x, y, sliceWidth, freqBinHeight);
        }
      }
      
      // Draw time grid and labels
      heatmapCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      heatmapCtx.lineWidth = 1;
      heatmapCtx.font = '10px Courier New';
      heatmapCtx.fillStyle = '#888';
      
      // Time markers: now, 15s, 30s, 1m, 2m, 5m, 10m
      const timeMarkers = [0, 15, 30, 60, 120, 300, 600];
      
      for (const seconds of timeMarkers) {
        if (oldestAge < seconds) continue; // Don't draw if we don't have data that old
        
        const x = ageToX(seconds);
        
        heatmapCtx.beginPath();
        heatmapCtx.moveTo(x, 0);
        heatmapCtx.lineTo(x, height);
        heatmapCtx.stroke();
        
        // Label
        let label;
        if (seconds === 0) label = 'now';
        else if (seconds < 60) label = seconds + 's';
        else label = (seconds / 60) + 'm';
        
        heatmapCtx.fillText(label, x + 2, 12);
      }
      
      // Draw frequency grid and labels
      const freqMarkers = [100, 500, 1000, 2000, 5000, 10000];
      
      for (const freq of freqMarkers) {
        if (freq > nyquist) continue;
        
        const binIndex = (freq / nyquist) * bufferLength;
        const y = height - (binIndex / bufferLength) * height;
        
        heatmapCtx.beginPath();
        heatmapCtx.moveTo(0, y);
        heatmapCtx.lineTo(width, y);
        heatmapCtx.stroke();
        
        // Label
        let label = freq >= 1000 ? (freq / 1000) + 'kHz' : freq + 'Hz';
        heatmapCtx.fillText(label, 2, y - 2);
      }
    }
  </script>
</body>
</html>
